/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
    combineCodec,
    getStructDecoder,
    getStructEncoder,
    getU8Decoder,
    getU8Encoder,
    SOLANA_ERROR__PROGRAM_CLIENTS__INSUFFICIENT_ACCOUNT_METAS,
    SolanaError,
    transformEncoder,
    type AccountMeta,
    type AccountSignerMeta,
    type Address,
    type FixedSizeCodec,
    type FixedSizeDecoder,
    type FixedSizeEncoder,
    type Instruction,
    type InstructionWithAccounts,
    type InstructionWithData,
    type ReadonlyAccount,
    type ReadonlyUint8Array,
    type TransactionSigner,
    type WritableAccount,
    type WritableSignerAccount,
} from '@solana/kit';
import {
    getAccountMetaFactory,
    getAddressFromResolvedInstructionAccount,
    type ResolvedInstructionAccount,
} from '@solana/kit/program-client-core';
import { findAssociatedTokenPda } from '../pdas';
import { ASSOCIATED_TOKEN_PROGRAM_ADDRESS } from '../programs';

export const CREATE_ASSOCIATED_TOKEN_IDEMPOTENT_DISCRIMINATOR = 1;

export function getCreateAssociatedTokenIdempotentDiscriminatorBytes() {
    return getU8Encoder().encode(CREATE_ASSOCIATED_TOKEN_IDEMPOTENT_DISCRIMINATOR);
}

export type CreateAssociatedTokenIdempotentInstruction<
    TProgram extends string = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,
    TAccountPayer extends string | AccountMeta<string> = string,
    TAccountAta extends string | AccountMeta<string> = string,
    TAccountOwner extends string | AccountMeta<string> = string,
    TAccountMint extends string | AccountMeta<string> = string,
    TAccountSystemProgram extends string | AccountMeta<string> = '11111111111111111111111111111111',
    TAccountTokenProgram extends string | AccountMeta<string> = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',
    TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
    InstructionWithData<ReadonlyUint8Array> &
    InstructionWithAccounts<
        [
            TAccountPayer extends string
                ? WritableSignerAccount<TAccountPayer> & AccountSignerMeta<TAccountPayer>
                : TAccountPayer,
            TAccountAta extends string ? WritableAccount<TAccountAta> : TAccountAta,
            TAccountOwner extends string ? ReadonlyAccount<TAccountOwner> : TAccountOwner,
            TAccountMint extends string ? ReadonlyAccount<TAccountMint> : TAccountMint,
            TAccountSystemProgram extends string ? ReadonlyAccount<TAccountSystemProgram> : TAccountSystemProgram,
            TAccountTokenProgram extends string ? ReadonlyAccount<TAccountTokenProgram> : TAccountTokenProgram,
            ...TRemainingAccounts,
        ]
    >;

export type CreateAssociatedTokenIdempotentInstructionData = { discriminator: number };

export type CreateAssociatedTokenIdempotentInstructionDataArgs = {};

export function getCreateAssociatedTokenIdempotentInstructionDataEncoder(): FixedSizeEncoder<CreateAssociatedTokenIdempotentInstructionDataArgs> {
    return transformEncoder(getStructEncoder([['discriminator', getU8Encoder()]]), value => ({
        ...value,
        discriminator: CREATE_ASSOCIATED_TOKEN_IDEMPOTENT_DISCRIMINATOR,
    }));
}

export function getCreateAssociatedTokenIdempotentInstructionDataDecoder(): FixedSizeDecoder<CreateAssociatedTokenIdempotentInstructionData> {
    return getStructDecoder([['discriminator', getU8Decoder()]]);
}

export function getCreateAssociatedTokenIdempotentInstructionDataCodec(): FixedSizeCodec<
    CreateAssociatedTokenIdempotentInstructionDataArgs,
    CreateAssociatedTokenIdempotentInstructionData
> {
    return combineCodec(
        getCreateAssociatedTokenIdempotentInstructionDataEncoder(),
        getCreateAssociatedTokenIdempotentInstructionDataDecoder(),
    );
}

export type CreateAssociatedTokenIdempotentAsyncInput<
    TAccountPayer extends string = string,
    TAccountAta extends string = string,
    TAccountOwner extends string = string,
    TAccountMint extends string = string,
    TAccountSystemProgram extends string = string,
    TAccountTokenProgram extends string = string,
> = {
    /** Funding account (must be a system account). */
    payer: TransactionSigner<TAccountPayer>;
    /** Associated token account address to be created. */
    ata?: Address<TAccountAta>;
    /** Wallet address for the new associated token account. */
    owner: Address<TAccountOwner>;
    /** The token mint for the new associated token account. */
    mint: Address<TAccountMint>;
    /** System program. */
    systemProgram?: Address<TAccountSystemProgram>;
    /** SPL Token program. */
    tokenProgram?: Address<TAccountTokenProgram>;
};

export async function getCreateAssociatedTokenIdempotentInstructionAsync<
    TAccountPayer extends string,
    TAccountAta extends string,
    TAccountOwner extends string,
    TAccountMint extends string,
    TAccountSystemProgram extends string,
    TAccountTokenProgram extends string,
    TProgramAddress extends Address = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,
>(
    input: CreateAssociatedTokenIdempotentAsyncInput<
        TAccountPayer,
        TAccountAta,
        TAccountOwner,
        TAccountMint,
        TAccountSystemProgram,
        TAccountTokenProgram
    >,
    config?: { programAddress?: TProgramAddress },
): Promise<
    CreateAssociatedTokenIdempotentInstruction<
        TProgramAddress,
        TAccountPayer,
        TAccountAta,
        TAccountOwner,
        TAccountMint,
        TAccountSystemProgram,
        TAccountTokenProgram
    >
> {
    // Program address.
    const programAddress = config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;

    // Original accounts.
    const originalAccounts = {
        payer: { value: input.payer ?? null, isWritable: true },
        ata: { value: input.ata ?? null, isWritable: true },
        owner: { value: input.owner ?? null, isWritable: false },
        mint: { value: input.mint ?? null, isWritable: false },
        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    };
    const accounts = originalAccounts as Record<keyof typeof originalAccounts, ResolvedInstructionAccount>;

    // Resolve default values.
    if (!accounts.tokenProgram.value) {
        accounts.tokenProgram.value =
            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;
    }
    if (!accounts.ata.value) {
        accounts.ata.value = await findAssociatedTokenPda({
            owner: getAddressFromResolvedInstructionAccount('owner', accounts.owner.value),
            tokenProgram: getAddressFromResolvedInstructionAccount('tokenProgram', accounts.tokenProgram.value),
            mint: getAddressFromResolvedInstructionAccount('mint', accounts.mint.value),
        });
    }
    if (!accounts.systemProgram.value) {
        accounts.systemProgram.value =
            '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
    }

    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
    return Object.freeze({
        accounts: [
            getAccountMeta('payer', accounts.payer),
            getAccountMeta('ata', accounts.ata),
            getAccountMeta('owner', accounts.owner),
            getAccountMeta('mint', accounts.mint),
            getAccountMeta('systemProgram', accounts.systemProgram),
            getAccountMeta('tokenProgram', accounts.tokenProgram),
        ],
        data: getCreateAssociatedTokenIdempotentInstructionDataEncoder().encode({}),
        programAddress,
    } as CreateAssociatedTokenIdempotentInstruction<
        TProgramAddress,
        TAccountPayer,
        TAccountAta,
        TAccountOwner,
        TAccountMint,
        TAccountSystemProgram,
        TAccountTokenProgram
    >);
}

export type CreateAssociatedTokenIdempotentInput<
    TAccountPayer extends string = string,
    TAccountAta extends string = string,
    TAccountOwner extends string = string,
    TAccountMint extends string = string,
    TAccountSystemProgram extends string = string,
    TAccountTokenProgram extends string = string,
> = {
    /** Funding account (must be a system account). */
    payer: TransactionSigner<TAccountPayer>;
    /** Associated token account address to be created. */
    ata: Address<TAccountAta>;
    /** Wallet address for the new associated token account. */
    owner: Address<TAccountOwner>;
    /** The token mint for the new associated token account. */
    mint: Address<TAccountMint>;
    /** System program. */
    systemProgram?: Address<TAccountSystemProgram>;
    /** SPL Token program. */
    tokenProgram?: Address<TAccountTokenProgram>;
};

export function getCreateAssociatedTokenIdempotentInstruction<
    TAccountPayer extends string,
    TAccountAta extends string,
    TAccountOwner extends string,
    TAccountMint extends string,
    TAccountSystemProgram extends string,
    TAccountTokenProgram extends string,
    TProgramAddress extends Address = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,
>(
    input: CreateAssociatedTokenIdempotentInput<
        TAccountPayer,
        TAccountAta,
        TAccountOwner,
        TAccountMint,
        TAccountSystemProgram,
        TAccountTokenProgram
    >,
    config?: { programAddress?: TProgramAddress },
): CreateAssociatedTokenIdempotentInstruction<
    TProgramAddress,
    TAccountPayer,
    TAccountAta,
    TAccountOwner,
    TAccountMint,
    TAccountSystemProgram,
    TAccountTokenProgram
> {
    // Program address.
    const programAddress = config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;

    // Original accounts.
    const originalAccounts = {
        payer: { value: input.payer ?? null, isWritable: true },
        ata: { value: input.ata ?? null, isWritable: true },
        owner: { value: input.owner ?? null, isWritable: false },
        mint: { value: input.mint ?? null, isWritable: false },
        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
        tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    };
    const accounts = originalAccounts as Record<keyof typeof originalAccounts, ResolvedInstructionAccount>;

    // Resolve default values.
    if (!accounts.tokenProgram.value) {
        accounts.tokenProgram.value =
            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;
    }
    if (!accounts.systemProgram.value) {
        accounts.systemProgram.value =
            '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
    }

    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
    return Object.freeze({
        accounts: [
            getAccountMeta('payer', accounts.payer),
            getAccountMeta('ata', accounts.ata),
            getAccountMeta('owner', accounts.owner),
            getAccountMeta('mint', accounts.mint),
            getAccountMeta('systemProgram', accounts.systemProgram),
            getAccountMeta('tokenProgram', accounts.tokenProgram),
        ],
        data: getCreateAssociatedTokenIdempotentInstructionDataEncoder().encode({}),
        programAddress,
    } as CreateAssociatedTokenIdempotentInstruction<
        TProgramAddress,
        TAccountPayer,
        TAccountAta,
        TAccountOwner,
        TAccountMint,
        TAccountSystemProgram,
        TAccountTokenProgram
    >);
}

export type ParsedCreateAssociatedTokenIdempotentInstruction<
    TProgram extends string = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,
    TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
    programAddress: Address<TProgram>;
    accounts: {
        /** Funding account (must be a system account). */
        payer: TAccountMetas[0];
        /** Associated token account address to be created. */
        ata: TAccountMetas[1];
        /** Wallet address for the new associated token account. */
        owner: TAccountMetas[2];
        /** The token mint for the new associated token account. */
        mint: TAccountMetas[3];
        /** System program. */
        systemProgram: TAccountMetas[4];
        /** SPL Token program. */
        tokenProgram: TAccountMetas[5];
    };
    data: CreateAssociatedTokenIdempotentInstructionData;
};

export function parseCreateAssociatedTokenIdempotentInstruction<
    TProgram extends string,
    TAccountMetas extends readonly AccountMeta[],
>(
    instruction: Instruction<TProgram> &
        InstructionWithAccounts<TAccountMetas> &
        InstructionWithData<ReadonlyUint8Array>,
): ParsedCreateAssociatedTokenIdempotentInstruction<TProgram, TAccountMetas> {
    if (instruction.accounts.length < 6) {
        throw new SolanaError(SOLANA_ERROR__PROGRAM_CLIENTS__INSUFFICIENT_ACCOUNT_METAS, {
            actualAccountMetas: instruction.accounts.length,
            expectedAccountMetas: 6,
        });
    }
    let accountIndex = 0;
    const getNextAccount = () => {
        const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
        accountIndex += 1;
        return accountMeta;
    };
    return {
        programAddress: instruction.programAddress,
        accounts: {
            payer: getNextAccount(),
            ata: getNextAccount(),
            owner: getNextAccount(),
            mint: getNextAccount(),
            systemProgram: getNextAccount(),
            tokenProgram: getNextAccount(),
        },
        data: getCreateAssociatedTokenIdempotentInstructionDataDecoder().decode(instruction.data),
    };
}
