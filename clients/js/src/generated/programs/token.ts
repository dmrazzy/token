/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
    assertIsInstructionWithAccounts,
    containsBytes,
    getU8Encoder,
    SOLANA_ERROR__PROGRAM_CLIENTS__FAILED_TO_IDENTIFY_ACCOUNT,
    SOLANA_ERROR__PROGRAM_CLIENTS__FAILED_TO_IDENTIFY_INSTRUCTION,
    SOLANA_ERROR__PROGRAM_CLIENTS__UNRECOGNIZED_INSTRUCTION_TYPE,
    SolanaError,
    type Address,
    type ClientWithRpc,
    type ClientWithTransactionPlanning,
    type ClientWithTransactionSending,
    type GetAccountInfoApi,
    type GetMultipleAccountsApi,
    type Instruction,
    type InstructionWithData,
    type ReadonlyUint8Array,
} from '@solana/kit';
import {
    addSelfFetchFunctions,
    addSelfPlanAndSendFunctions,
    type SelfFetchFunctions,
    type SelfPlanAndSendFunctions,
} from '@solana/kit/program-client-core';
import {
    getMintCodec,
    getMultisigCodec,
    getTokenCodec,
    type Mint,
    type MintArgs,
    type Multisig,
    type MultisigArgs,
    type Token,
    type TokenArgs,
} from '../accounts';
import {
    getAmountToUiAmountInstruction,
    getApproveCheckedInstruction,
    getApproveInstruction,
    getBurnCheckedInstruction,
    getBurnInstruction,
    getCloseAccountInstruction,
    getFreezeAccountInstruction,
    getGetAccountDataSizeInstruction,
    getInitializeAccount2Instruction,
    getInitializeAccount3Instruction,
    getInitializeAccountInstruction,
    getInitializeImmutableOwnerInstruction,
    getInitializeMint2Instruction,
    getInitializeMintInstruction,
    getInitializeMultisig2Instruction,
    getInitializeMultisigInstruction,
    getMintToCheckedInstruction,
    getMintToInstruction,
    getRevokeInstruction,
    getSetAuthorityInstruction,
    getSyncNativeInstruction,
    getThawAccountInstruction,
    getTransferCheckedInstruction,
    getTransferInstruction,
    getUiAmountToAmountInstruction,
    parseAmountToUiAmountInstruction,
    parseApproveCheckedInstruction,
    parseApproveInstruction,
    parseBurnCheckedInstruction,
    parseBurnInstruction,
    parseCloseAccountInstruction,
    parseFreezeAccountInstruction,
    parseGetAccountDataSizeInstruction,
    parseInitializeAccount2Instruction,
    parseInitializeAccount3Instruction,
    parseInitializeAccountInstruction,
    parseInitializeImmutableOwnerInstruction,
    parseInitializeMint2Instruction,
    parseInitializeMintInstruction,
    parseInitializeMultisig2Instruction,
    parseInitializeMultisigInstruction,
    parseMintToCheckedInstruction,
    parseMintToInstruction,
    parseRevokeInstruction,
    parseSetAuthorityInstruction,
    parseSyncNativeInstruction,
    parseThawAccountInstruction,
    parseTransferCheckedInstruction,
    parseTransferInstruction,
    parseUiAmountToAmountInstruction,
    type AmountToUiAmountInput,
    type ApproveCheckedInput,
    type ApproveInput,
    type BurnCheckedInput,
    type BurnInput,
    type CloseAccountInput,
    type FreezeAccountInput,
    type GetAccountDataSizeInput,
    type InitializeAccount2Input,
    type InitializeAccount3Input,
    type InitializeAccountInput,
    type InitializeImmutableOwnerInput,
    type InitializeMint2Input,
    type InitializeMintInput,
    type InitializeMultisig2Input,
    type InitializeMultisigInput,
    type MintToCheckedInput,
    type MintToInput,
    type ParsedAmountToUiAmountInstruction,
    type ParsedApproveCheckedInstruction,
    type ParsedApproveInstruction,
    type ParsedBurnCheckedInstruction,
    type ParsedBurnInstruction,
    type ParsedCloseAccountInstruction,
    type ParsedFreezeAccountInstruction,
    type ParsedGetAccountDataSizeInstruction,
    type ParsedInitializeAccount2Instruction,
    type ParsedInitializeAccount3Instruction,
    type ParsedInitializeAccountInstruction,
    type ParsedInitializeImmutableOwnerInstruction,
    type ParsedInitializeMint2Instruction,
    type ParsedInitializeMintInstruction,
    type ParsedInitializeMultisig2Instruction,
    type ParsedInitializeMultisigInstruction,
    type ParsedMintToCheckedInstruction,
    type ParsedMintToInstruction,
    type ParsedRevokeInstruction,
    type ParsedSetAuthorityInstruction,
    type ParsedSyncNativeInstruction,
    type ParsedThawAccountInstruction,
    type ParsedTransferCheckedInstruction,
    type ParsedTransferInstruction,
    type ParsedUiAmountToAmountInstruction,
    type RevokeInput,
    type SetAuthorityInput,
    type SyncNativeInput,
    type ThawAccountInput,
    type TransferCheckedInput,
    type TransferInput,
    type UiAmountToAmountInput,
} from '../instructions';

export const TOKEN_PROGRAM_ADDRESS =
    'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;

export enum TokenAccount {
    Mint,
    Token,
    Multisig,
}

export function identifyTokenAccount(account: { data: ReadonlyUint8Array } | ReadonlyUint8Array): TokenAccount {
    const data = 'data' in account ? account.data : account;
    if (data.length === 82) {
        return TokenAccount.Mint;
    }
    if (data.length === 165) {
        return TokenAccount.Token;
    }
    if (data.length === 355) {
        return TokenAccount.Multisig;
    }
    throw new SolanaError(SOLANA_ERROR__PROGRAM_CLIENTS__FAILED_TO_IDENTIFY_ACCOUNT, {
        accountData: data,
        programName: 'token',
    });
}

export enum TokenInstruction {
    InitializeMint,
    InitializeAccount,
    InitializeMultisig,
    Transfer,
    Approve,
    Revoke,
    SetAuthority,
    MintTo,
    Burn,
    CloseAccount,
    FreezeAccount,
    ThawAccount,
    TransferChecked,
    ApproveChecked,
    MintToChecked,
    BurnChecked,
    InitializeAccount2,
    SyncNative,
    InitializeAccount3,
    InitializeMultisig2,
    InitializeMint2,
    GetAccountDataSize,
    InitializeImmutableOwner,
    AmountToUiAmount,
    UiAmountToAmount,
}

export function identifyTokenInstruction(
    instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): TokenInstruction {
    const data = 'data' in instruction ? instruction.data : instruction;
    if (containsBytes(data, getU8Encoder().encode(0), 0)) {
        return TokenInstruction.InitializeMint;
    }
    if (containsBytes(data, getU8Encoder().encode(1), 0)) {
        return TokenInstruction.InitializeAccount;
    }
    if (containsBytes(data, getU8Encoder().encode(2), 0)) {
        return TokenInstruction.InitializeMultisig;
    }
    if (containsBytes(data, getU8Encoder().encode(3), 0)) {
        return TokenInstruction.Transfer;
    }
    if (containsBytes(data, getU8Encoder().encode(4), 0)) {
        return TokenInstruction.Approve;
    }
    if (containsBytes(data, getU8Encoder().encode(5), 0)) {
        return TokenInstruction.Revoke;
    }
    if (containsBytes(data, getU8Encoder().encode(6), 0)) {
        return TokenInstruction.SetAuthority;
    }
    if (containsBytes(data, getU8Encoder().encode(7), 0)) {
        return TokenInstruction.MintTo;
    }
    if (containsBytes(data, getU8Encoder().encode(8), 0)) {
        return TokenInstruction.Burn;
    }
    if (containsBytes(data, getU8Encoder().encode(9), 0)) {
        return TokenInstruction.CloseAccount;
    }
    if (containsBytes(data, getU8Encoder().encode(10), 0)) {
        return TokenInstruction.FreezeAccount;
    }
    if (containsBytes(data, getU8Encoder().encode(11), 0)) {
        return TokenInstruction.ThawAccount;
    }
    if (containsBytes(data, getU8Encoder().encode(12), 0)) {
        return TokenInstruction.TransferChecked;
    }
    if (containsBytes(data, getU8Encoder().encode(13), 0)) {
        return TokenInstruction.ApproveChecked;
    }
    if (containsBytes(data, getU8Encoder().encode(14), 0)) {
        return TokenInstruction.MintToChecked;
    }
    if (containsBytes(data, getU8Encoder().encode(15), 0)) {
        return TokenInstruction.BurnChecked;
    }
    if (containsBytes(data, getU8Encoder().encode(16), 0)) {
        return TokenInstruction.InitializeAccount2;
    }
    if (containsBytes(data, getU8Encoder().encode(17), 0)) {
        return TokenInstruction.SyncNative;
    }
    if (containsBytes(data, getU8Encoder().encode(18), 0)) {
        return TokenInstruction.InitializeAccount3;
    }
    if (containsBytes(data, getU8Encoder().encode(19), 0)) {
        return TokenInstruction.InitializeMultisig2;
    }
    if (containsBytes(data, getU8Encoder().encode(20), 0)) {
        return TokenInstruction.InitializeMint2;
    }
    if (containsBytes(data, getU8Encoder().encode(21), 0)) {
        return TokenInstruction.GetAccountDataSize;
    }
    if (containsBytes(data, getU8Encoder().encode(22), 0)) {
        return TokenInstruction.InitializeImmutableOwner;
    }
    if (containsBytes(data, getU8Encoder().encode(23), 0)) {
        return TokenInstruction.AmountToUiAmount;
    }
    if (containsBytes(data, getU8Encoder().encode(24), 0)) {
        return TokenInstruction.UiAmountToAmount;
    }
    throw new SolanaError(SOLANA_ERROR__PROGRAM_CLIENTS__FAILED_TO_IDENTIFY_INSTRUCTION, {
        instructionData: data,
        programName: 'token',
    });
}

export type ParsedTokenInstruction<TProgram extends string = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'> =
    | ({ instructionType: TokenInstruction.InitializeMint } & ParsedInitializeMintInstruction<TProgram>)
    | ({ instructionType: TokenInstruction.InitializeAccount } & ParsedInitializeAccountInstruction<TProgram>)
    | ({ instructionType: TokenInstruction.InitializeMultisig } & ParsedInitializeMultisigInstruction<TProgram>)
    | ({ instructionType: TokenInstruction.Transfer } & ParsedTransferInstruction<TProgram>)
    | ({ instructionType: TokenInstruction.Approve } & ParsedApproveInstruction<TProgram>)
    | ({ instructionType: TokenInstruction.Revoke } & ParsedRevokeInstruction<TProgram>)
    | ({ instructionType: TokenInstruction.SetAuthority } & ParsedSetAuthorityInstruction<TProgram>)
    | ({ instructionType: TokenInstruction.MintTo } & ParsedMintToInstruction<TProgram>)
    | ({ instructionType: TokenInstruction.Burn } & ParsedBurnInstruction<TProgram>)
    | ({ instructionType: TokenInstruction.CloseAccount } & ParsedCloseAccountInstruction<TProgram>)
    | ({ instructionType: TokenInstruction.FreezeAccount } & ParsedFreezeAccountInstruction<TProgram>)
    | ({ instructionType: TokenInstruction.ThawAccount } & ParsedThawAccountInstruction<TProgram>)
    | ({ instructionType: TokenInstruction.TransferChecked } & ParsedTransferCheckedInstruction<TProgram>)
    | ({ instructionType: TokenInstruction.ApproveChecked } & ParsedApproveCheckedInstruction<TProgram>)
    | ({ instructionType: TokenInstruction.MintToChecked } & ParsedMintToCheckedInstruction<TProgram>)
    | ({ instructionType: TokenInstruction.BurnChecked } & ParsedBurnCheckedInstruction<TProgram>)
    | ({ instructionType: TokenInstruction.InitializeAccount2 } & ParsedInitializeAccount2Instruction<TProgram>)
    | ({ instructionType: TokenInstruction.SyncNative } & ParsedSyncNativeInstruction<TProgram>)
    | ({ instructionType: TokenInstruction.InitializeAccount3 } & ParsedInitializeAccount3Instruction<TProgram>)
    | ({ instructionType: TokenInstruction.InitializeMultisig2 } & ParsedInitializeMultisig2Instruction<TProgram>)
    | ({ instructionType: TokenInstruction.InitializeMint2 } & ParsedInitializeMint2Instruction<TProgram>)
    | ({ instructionType: TokenInstruction.GetAccountDataSize } & ParsedGetAccountDataSizeInstruction<TProgram>)
    | ({
          instructionType: TokenInstruction.InitializeImmutableOwner;
      } & ParsedInitializeImmutableOwnerInstruction<TProgram>)
    | ({ instructionType: TokenInstruction.AmountToUiAmount } & ParsedAmountToUiAmountInstruction<TProgram>)
    | ({ instructionType: TokenInstruction.UiAmountToAmount } & ParsedUiAmountToAmountInstruction<TProgram>);

export function parseTokenInstruction<TProgram extends string>(
    instruction: Instruction<TProgram> & InstructionWithData<ReadonlyUint8Array>,
): ParsedTokenInstruction<TProgram> {
    const instructionType = identifyTokenInstruction(instruction);
    switch (instructionType) {
        case TokenInstruction.InitializeMint: {
            assertIsInstructionWithAccounts(instruction);
            return { instructionType: TokenInstruction.InitializeMint, ...parseInitializeMintInstruction(instruction) };
        }
        case TokenInstruction.InitializeAccount: {
            assertIsInstructionWithAccounts(instruction);
            return {
                instructionType: TokenInstruction.InitializeAccount,
                ...parseInitializeAccountInstruction(instruction),
            };
        }
        case TokenInstruction.InitializeMultisig: {
            assertIsInstructionWithAccounts(instruction);
            return {
                instructionType: TokenInstruction.InitializeMultisig,
                ...parseInitializeMultisigInstruction(instruction),
            };
        }
        case TokenInstruction.Transfer: {
            assertIsInstructionWithAccounts(instruction);
            return { instructionType: TokenInstruction.Transfer, ...parseTransferInstruction(instruction) };
        }
        case TokenInstruction.Approve: {
            assertIsInstructionWithAccounts(instruction);
            return { instructionType: TokenInstruction.Approve, ...parseApproveInstruction(instruction) };
        }
        case TokenInstruction.Revoke: {
            assertIsInstructionWithAccounts(instruction);
            return { instructionType: TokenInstruction.Revoke, ...parseRevokeInstruction(instruction) };
        }
        case TokenInstruction.SetAuthority: {
            assertIsInstructionWithAccounts(instruction);
            return { instructionType: TokenInstruction.SetAuthority, ...parseSetAuthorityInstruction(instruction) };
        }
        case TokenInstruction.MintTo: {
            assertIsInstructionWithAccounts(instruction);
            return { instructionType: TokenInstruction.MintTo, ...parseMintToInstruction(instruction) };
        }
        case TokenInstruction.Burn: {
            assertIsInstructionWithAccounts(instruction);
            return { instructionType: TokenInstruction.Burn, ...parseBurnInstruction(instruction) };
        }
        case TokenInstruction.CloseAccount: {
            assertIsInstructionWithAccounts(instruction);
            return { instructionType: TokenInstruction.CloseAccount, ...parseCloseAccountInstruction(instruction) };
        }
        case TokenInstruction.FreezeAccount: {
            assertIsInstructionWithAccounts(instruction);
            return { instructionType: TokenInstruction.FreezeAccount, ...parseFreezeAccountInstruction(instruction) };
        }
        case TokenInstruction.ThawAccount: {
            assertIsInstructionWithAccounts(instruction);
            return { instructionType: TokenInstruction.ThawAccount, ...parseThawAccountInstruction(instruction) };
        }
        case TokenInstruction.TransferChecked: {
            assertIsInstructionWithAccounts(instruction);
            return {
                instructionType: TokenInstruction.TransferChecked,
                ...parseTransferCheckedInstruction(instruction),
            };
        }
        case TokenInstruction.ApproveChecked: {
            assertIsInstructionWithAccounts(instruction);
            return { instructionType: TokenInstruction.ApproveChecked, ...parseApproveCheckedInstruction(instruction) };
        }
        case TokenInstruction.MintToChecked: {
            assertIsInstructionWithAccounts(instruction);
            return { instructionType: TokenInstruction.MintToChecked, ...parseMintToCheckedInstruction(instruction) };
        }
        case TokenInstruction.BurnChecked: {
            assertIsInstructionWithAccounts(instruction);
            return { instructionType: TokenInstruction.BurnChecked, ...parseBurnCheckedInstruction(instruction) };
        }
        case TokenInstruction.InitializeAccount2: {
            assertIsInstructionWithAccounts(instruction);
            return {
                instructionType: TokenInstruction.InitializeAccount2,
                ...parseInitializeAccount2Instruction(instruction),
            };
        }
        case TokenInstruction.SyncNative: {
            assertIsInstructionWithAccounts(instruction);
            return { instructionType: TokenInstruction.SyncNative, ...parseSyncNativeInstruction(instruction) };
        }
        case TokenInstruction.InitializeAccount3: {
            assertIsInstructionWithAccounts(instruction);
            return {
                instructionType: TokenInstruction.InitializeAccount3,
                ...parseInitializeAccount3Instruction(instruction),
            };
        }
        case TokenInstruction.InitializeMultisig2: {
            assertIsInstructionWithAccounts(instruction);
            return {
                instructionType: TokenInstruction.InitializeMultisig2,
                ...parseInitializeMultisig2Instruction(instruction),
            };
        }
        case TokenInstruction.InitializeMint2: {
            assertIsInstructionWithAccounts(instruction);
            return {
                instructionType: TokenInstruction.InitializeMint2,
                ...parseInitializeMint2Instruction(instruction),
            };
        }
        case TokenInstruction.GetAccountDataSize: {
            assertIsInstructionWithAccounts(instruction);
            return {
                instructionType: TokenInstruction.GetAccountDataSize,
                ...parseGetAccountDataSizeInstruction(instruction),
            };
        }
        case TokenInstruction.InitializeImmutableOwner: {
            assertIsInstructionWithAccounts(instruction);
            return {
                instructionType: TokenInstruction.InitializeImmutableOwner,
                ...parseInitializeImmutableOwnerInstruction(instruction),
            };
        }
        case TokenInstruction.AmountToUiAmount: {
            assertIsInstructionWithAccounts(instruction);
            return {
                instructionType: TokenInstruction.AmountToUiAmount,
                ...parseAmountToUiAmountInstruction(instruction),
            };
        }
        case TokenInstruction.UiAmountToAmount: {
            assertIsInstructionWithAccounts(instruction);
            return {
                instructionType: TokenInstruction.UiAmountToAmount,
                ...parseUiAmountToAmountInstruction(instruction),
            };
        }
        default:
            throw new SolanaError(SOLANA_ERROR__PROGRAM_CLIENTS__UNRECOGNIZED_INSTRUCTION_TYPE, {
                instructionType: instructionType as string,
                programName: 'token',
            });
    }
}

export type TokenPlugin = { accounts: TokenPluginAccounts; instructions: TokenPluginInstructions };

export type TokenPluginAccounts = {
    mint: ReturnType<typeof getMintCodec> & SelfFetchFunctions<MintArgs, Mint>;
    token: ReturnType<typeof getTokenCodec> & SelfFetchFunctions<TokenArgs, Token>;
    multisig: ReturnType<typeof getMultisigCodec> & SelfFetchFunctions<MultisigArgs, Multisig>;
};

export type TokenPluginInstructions = {
    initializeMint: (
        input: InitializeMintInput,
    ) => ReturnType<typeof getInitializeMintInstruction> & SelfPlanAndSendFunctions;
    initializeAccount: (
        input: InitializeAccountInput,
    ) => ReturnType<typeof getInitializeAccountInstruction> & SelfPlanAndSendFunctions;
    initializeMultisig: (
        input: InitializeMultisigInput,
    ) => ReturnType<typeof getInitializeMultisigInstruction> & SelfPlanAndSendFunctions;
    transfer: (input: TransferInput) => ReturnType<typeof getTransferInstruction> & SelfPlanAndSendFunctions;
    approve: (input: ApproveInput) => ReturnType<typeof getApproveInstruction> & SelfPlanAndSendFunctions;
    revoke: (input: RevokeInput) => ReturnType<typeof getRevokeInstruction> & SelfPlanAndSendFunctions;
    setAuthority: (
        input: SetAuthorityInput,
    ) => ReturnType<typeof getSetAuthorityInstruction> & SelfPlanAndSendFunctions;
    mintTo: (input: MintToInput) => ReturnType<typeof getMintToInstruction> & SelfPlanAndSendFunctions;
    burn: (input: BurnInput) => ReturnType<typeof getBurnInstruction> & SelfPlanAndSendFunctions;
    closeAccount: (
        input: CloseAccountInput,
    ) => ReturnType<typeof getCloseAccountInstruction> & SelfPlanAndSendFunctions;
    freezeAccount: (
        input: FreezeAccountInput,
    ) => ReturnType<typeof getFreezeAccountInstruction> & SelfPlanAndSendFunctions;
    thawAccount: (input: ThawAccountInput) => ReturnType<typeof getThawAccountInstruction> & SelfPlanAndSendFunctions;
    transferChecked: (
        input: TransferCheckedInput,
    ) => ReturnType<typeof getTransferCheckedInstruction> & SelfPlanAndSendFunctions;
    approveChecked: (
        input: ApproveCheckedInput,
    ) => ReturnType<typeof getApproveCheckedInstruction> & SelfPlanAndSendFunctions;
    mintToChecked: (
        input: MintToCheckedInput,
    ) => ReturnType<typeof getMintToCheckedInstruction> & SelfPlanAndSendFunctions;
    burnChecked: (input: BurnCheckedInput) => ReturnType<typeof getBurnCheckedInstruction> & SelfPlanAndSendFunctions;
    initializeAccount2: (
        input: InitializeAccount2Input,
    ) => ReturnType<typeof getInitializeAccount2Instruction> & SelfPlanAndSendFunctions;
    syncNative: (input: SyncNativeInput) => ReturnType<typeof getSyncNativeInstruction> & SelfPlanAndSendFunctions;
    initializeAccount3: (
        input: InitializeAccount3Input,
    ) => ReturnType<typeof getInitializeAccount3Instruction> & SelfPlanAndSendFunctions;
    initializeMultisig2: (
        input: InitializeMultisig2Input,
    ) => ReturnType<typeof getInitializeMultisig2Instruction> & SelfPlanAndSendFunctions;
    initializeMint2: (
        input: InitializeMint2Input,
    ) => ReturnType<typeof getInitializeMint2Instruction> & SelfPlanAndSendFunctions;
    getAccountDataSize: (
        input: GetAccountDataSizeInput,
    ) => ReturnType<typeof getGetAccountDataSizeInstruction> & SelfPlanAndSendFunctions;
    initializeImmutableOwner: (
        input: InitializeImmutableOwnerInput,
    ) => ReturnType<typeof getInitializeImmutableOwnerInstruction> & SelfPlanAndSendFunctions;
    amountToUiAmount: (
        input: AmountToUiAmountInput,
    ) => ReturnType<typeof getAmountToUiAmountInstruction> & SelfPlanAndSendFunctions;
    uiAmountToAmount: (
        input: UiAmountToAmountInput,
    ) => ReturnType<typeof getUiAmountToAmountInstruction> & SelfPlanAndSendFunctions;
};

export type TokenPluginRequirements = ClientWithRpc<GetAccountInfoApi & GetMultipleAccountsApi> &
    ClientWithTransactionPlanning &
    ClientWithTransactionSending;

export function tokenProgram() {
    return <T extends TokenPluginRequirements>(client: T) => {
        return {
            ...client,
            token: <TokenPlugin>{
                accounts: {
                    mint: addSelfFetchFunctions(client, getMintCodec()),
                    token: addSelfFetchFunctions(client, getTokenCodec()),
                    multisig: addSelfFetchFunctions(client, getMultisigCodec()),
                },
                instructions: {
                    initializeMint: input => addSelfPlanAndSendFunctions(client, getInitializeMintInstruction(input)),
                    initializeAccount: input =>
                        addSelfPlanAndSendFunctions(client, getInitializeAccountInstruction(input)),
                    initializeMultisig: input =>
                        addSelfPlanAndSendFunctions(client, getInitializeMultisigInstruction(input)),
                    transfer: input => addSelfPlanAndSendFunctions(client, getTransferInstruction(input)),
                    approve: input => addSelfPlanAndSendFunctions(client, getApproveInstruction(input)),
                    revoke: input => addSelfPlanAndSendFunctions(client, getRevokeInstruction(input)),
                    setAuthority: input => addSelfPlanAndSendFunctions(client, getSetAuthorityInstruction(input)),
                    mintTo: input => addSelfPlanAndSendFunctions(client, getMintToInstruction(input)),
                    burn: input => addSelfPlanAndSendFunctions(client, getBurnInstruction(input)),
                    closeAccount: input => addSelfPlanAndSendFunctions(client, getCloseAccountInstruction(input)),
                    freezeAccount: input => addSelfPlanAndSendFunctions(client, getFreezeAccountInstruction(input)),
                    thawAccount: input => addSelfPlanAndSendFunctions(client, getThawAccountInstruction(input)),
                    transferChecked: input => addSelfPlanAndSendFunctions(client, getTransferCheckedInstruction(input)),
                    approveChecked: input => addSelfPlanAndSendFunctions(client, getApproveCheckedInstruction(input)),
                    mintToChecked: input => addSelfPlanAndSendFunctions(client, getMintToCheckedInstruction(input)),
                    burnChecked: input => addSelfPlanAndSendFunctions(client, getBurnCheckedInstruction(input)),
                    initializeAccount2: input =>
                        addSelfPlanAndSendFunctions(client, getInitializeAccount2Instruction(input)),
                    syncNative: input => addSelfPlanAndSendFunctions(client, getSyncNativeInstruction(input)),
                    initializeAccount3: input =>
                        addSelfPlanAndSendFunctions(client, getInitializeAccount3Instruction(input)),
                    initializeMultisig2: input =>
                        addSelfPlanAndSendFunctions(client, getInitializeMultisig2Instruction(input)),
                    initializeMint2: input => addSelfPlanAndSendFunctions(client, getInitializeMint2Instruction(input)),
                    getAccountDataSize: input =>
                        addSelfPlanAndSendFunctions(client, getGetAccountDataSizeInstruction(input)),
                    initializeImmutableOwner: input =>
                        addSelfPlanAndSendFunctions(client, getInitializeImmutableOwnerInstruction(input)),
                    amountToUiAmount: input =>
                        addSelfPlanAndSendFunctions(client, getAmountToUiAmountInstruction(input)),
                    uiAmountToAmount: input =>
                        addSelfPlanAndSendFunctions(client, getUiAmountToAmountInstruction(input)),
                },
            },
        };
    };
}
